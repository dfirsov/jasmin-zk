
type T.
op P : T -> bool.
axiom inhabited: exists x, P x.
type do_not_use_this_type_or_you_get_unsoundness_admit.
lemma injection: exists (f : do_not_use_this_type_or_you_get_unsoundness_admit -> T), injective f /\ (forall x, P x <=> exists y, x = f y).
  admit.
qed.

op internal_val = choiceb (fun(f : do_not_use_this_type_or_you_get_unsoundness_admit -> T), injective f /\ (forall (x:T), ((P x) <=> exists y, x = f y))) witness.

type sT = [Wrap of do_not_use_this_type_or_you_get_unsoundness_admit].


op val (x : sT) : T = with x = Wrap x' => internal_val x'.

op pinverse (f : 'a -> 'b) (y : 'b) : 'a option = if exists x, y = f x then Some (choiceb (fun x, y = f x) witness) else None.

lemma val_range x: P x <=> exists y, x = val y.
  have H: (fun(f : do_not_use_this_type_or_you_get_unsoundness_admit -> T), injective f /\ (forall (x:T), ((P x) <=> exists y, x = f y))) internal_val.
    apply choicebP. by apply injection.
  have H1: P x => exists (y : sT), x = val y.
    move => Px.
    have exy: exists y, x = internal_val y.
      smt().
    elim exy => *.
    smt().
  have H2: (exists (y : sT), x = val y) => P x.
    move => ex.
    elim ex => *.
    smt().
  progress.
qed.

lemma val_inj: injective val.
  have H: (fun(f : do_not_use_this_type_or_you_get_unsoundness_admit -> T), injective f /\ (forall (x:T), ((P x) <=> exists y, x = f y))) internal_val.
    apply choicebP. by apply injection.
  smt().
qed.

lemma valP (x : sT): P (val x).
  smt (val_range).
qed.

op insub : T -> sT option = pinverse val.

lemma pinverseN (f:'a->'b) x: (!exists y, x = f y) => pinverse f x = None.
  smt().
qed.

lemma insubN (x : T): !P x => insub x = None.
  rewrite /insub => notPx.
  apply pinverseN.
  smt(val_range).
qed.

lemma pinverse_inv (f:'a->'b) x: (exists y, x = f y) => omap f (pinverse f x) = Some x.
  move => H. elim H => y fy.
  have H: pinverse f x = Some (choiceb (fun y, x = f y) witness).
    smt().
  have H1: (fun y, x = f y) (choiceb (fun y, x = f y) witness).
    apply choicebP. smt().
  smt().
qed.

lemma pcancel_pinverse (f : 'a->'b): injective f => pcancel f (pinverse f).
  move => inj_f.
  rewrite /pcancel => x.
  have H: omap f (pinverse f (f x)) = Some (f x).
    apply pinverse_inv. smt().
  smt().
qed.

lemma valK: pcancel val insub.
  rewrite /insub. apply pcancel_pinverse. apply val_inj.
qed.

lemma insubT (x : T):  P x => omap val (insub x) = Some x.
  move => Px.
  rewrite /insub. 
  apply pinverse_inv.
  smt(val_range).
qed.

op wsT = val witness.

lemma insubW: insub wsT = Some witness<:sT>.
  smt (valK).
qed.

op insubd (x : T) = odflt witness (insub x).

lemma valKd: cancel val insubd.
proof. by move=> u; rewrite /insubd valK. qed.

lemma insubP (x : T):           (* We need inductive predicates *)
     (exists u, P x /\ insub x = Some u /\ val u = x)
  \/ (!P x /\ insub x = None).
proof.                          (* this proof script is awful *)
  case (P x)=> [Px | /insubN -> //]; left.
  move: Px => /insubT; case {-2}(insub x) (eq_refl (insub x))=> //.
  by move=> /= u eq_insub eqx; exists u => /=; move: eqx => ->.
qed.

lemma val_insubd x: val (insubd x) = if P x then x else val witness.
proof. by rewrite /insubd; case (insubP x) => [[u] [->] [->]|[-> ->]]. qed.

lemma insubdK (x : T): P x => val (insubd x) = x.
proof. by move=> Px; rewrite val_insubd Px. qed.

(* -------------------------------------------------------------------- *)
theory Lift.
  op lift1 (f : T -> T) =
    fun (z : sT), insubd (f (val z)).

  op lift2 (f : T -> T -> T) =
    fun (z1 z2 : sT), insubd (f (val z1) (val z2)).

  lemma lift1E (f : T -> T):
       (forall x, P x => P (f x))
    => forall x, val (lift1 f x) = f (val x).
  proof. by move=> h x; rewrite /lift1 insubdK ?h ?valP. qed.

  lemma lift2E (f : T -> T -> T):
       (forall x y, P x => P y => P (f x y))
    => forall x y, val (lift2 f x y) = f (val x) (val y).
  proof. by move=> h x y; rewrite /lift2 insubdK ?h ?valP. qed.
end Lift.
