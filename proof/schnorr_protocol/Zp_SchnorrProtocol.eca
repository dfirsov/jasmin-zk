require import Int IntDiv.
require import Real.
require import Distr.
require import List.
require import StdOrder.
import Ring.IntID IntOrder.

require (*--*) Subtype.

require Abstract_SchnorrProtocol.
require ZModPStar.

require ZModP.
clone import ZModP.ZModField as Zp.

clone ZModPStar as ZPS with op p <- Zp.p,
                            theory ZpF <= Zp.


import ZPS.


op q : int.
axiom q_prime : prime q.

op g : ZPS.zmod.
axiom g_q_assumption: (ZModpField.exp g q) = Zp.one.

op challenges_list_zp  = [0;1].
axiom list_elems x : x \in challenges_list_zp => 0 <= x < q.

lemma g_unit : unit g.  
apply (Zp.ComRing.unitP g (ZModpField.exp g (q-1))).
have ->: (ZModpField.exp g (q - 1)) * g = (ZModpField.exp g (q - 1)) * (ZModpField.exp g 1). smt(@ZModpField).
have ->: (ZModpField.exp g (q - 1)) * (ZModpField.exp g 1) = (ZModpField.exp g ((q - 1) + 1)).
rewrite - ZModpField.exprD. 
apply (ZModpField.unitrX_neq0 g q). smt(q_prime). smt(g_q_assumption @ZModpField).
simplify. auto.
simplify. apply g_q_assumption. qed.

lemma lll' (z : zmod) : unit z => forall x, 0 <= x 
  => Zps.(^) (Sub.insubd z)  x = Sub.insubd (ZModpField.exp z x). 
move => z_unit. apply intind. progress. smt. progress. smt(@Zps @Sub @ZModpField).
qed.

clone import Abstract_SchnorrProtocol as LSP with
  op g <- Sub.insubd g,
  op q <- q,
  op challenges_list <- map EG.inzmod challenges_list_zp,
  theory CG <- ZPS.Zps
proof g_is_generator, q_prime.
realize g_is_generator.  rewrite lll'. apply g_unit. smt(q_prime).
rewrite g_q_assumption. auto. qed.
realize q_prime.  apply q_prime. qed.

  

type statement   = zmod.           (* statement  *)
type witness     = int.            (* witness    *)
type commitment  = zmod.           (* commitment *)
type response    = int.            (* response   *)
type challenge   = int.            (* challenge  *)
type secret      = int.

module type ZKProverG = {
  proc commitment() : commitment * secret
  proc response(w : witness, r : secret, c : challenge) : response
}.

module type ZKVerifierG = {
  proc challenge() : challenge
  proc verify(s : statement, z : commitment, c : challenge, t : response) :
    bool
}.

module SchnorrProver : ZKProverG = {
  proc commitment() : commitment * secret = {
    var r : secret;
    r <$ [0..q-1]; 
    return (ZModpField.exp g r, r);
  }
  proc response(w: witness, r:secret, c: challenge) : response = {
    c <- (c %% q \in challenges_list_zp) ? c %% q : 0;
    return (r + c * w) %% q;
  }
}.


module SchnorrVerifier : ZKVerifierG = {
  proc challenge() : challenge = {
    var c;
    c <$ duniform challenges_list_zp;
    return c;
  }
  proc verify(s: statement, z: commitment, c: challenge, t: response) : bool = {
    return ((ZModpField.exp g t) = (ZModpField.exp s c) * z) /\ (ZModpField.exp s q) = Zp.one;
  }
}.


module CompletenessG(P : ZKProverG, V : ZKVerifierG) = {
  proc main(s:statement, w:witness) = {
    var z, c, r,t,v;
    (z,r) <@ P.commitment();
    c <@ V.challenge();
    t <@ P.response(w,r,c);
    v <@ V.verify(s,z,c,t);
    return v;
  }
}.


op completeness_relationG (s:statement) (w:witness) = (ZModpField.exp g w) = s.

lemma exp_lemma6 (z : zmod) : unit z => forall n,  unit (ZModpField.exp z n).
progress. apply ZModpRing.unitrX. auto.
qed.


lemma lll'' (z : zmod) : unit z => forall x, x < 0 => Zps.(^) (Sub.insubd z) x = Zps.inv (Zps.(^) (Sub.insubd z) (- x)).
smt().
qed.

lemma lll (z : zmod) : unit z => forall x, Zps.(^) (Sub.insubd z)  x = Sub.insubd (ZModpField.exp z x). 
move => zu.
move => x.
case (0 <= x).  apply lll'. auto.
move => xl.
rewrite lll''. auto. smt().
rewrite lll'. auto. smt().
smt(@ZModpField @Sub).       
qed.

lemma bbb : forall (a b : zmods), (Sub.val a = Sub.val b) <=> (a = b). smt. qed.
lemma aaa : forall (a b : zmod), (unit a) => (unit b) => (Sub.insubd a = Sub.insubd b) => (a = b). smt(@Sub). qed.

lemma completeness_relation_compatible : forall s w, completeness_relationG s w => completeness_relation (Sub.insubd s) (EG.inzmod w).
move => s w h. rewrite /completeness_relationG /completeness_relation /IsDL /=. (* move => eq. *)
rewrite /(^^).
rewrite EG.inzmodK.
rewrite - pow_mod. 
rewrite lll. apply g_unit. auto.
rewrite - bbb.
rewrite - h. auto.
qed.


lemma completeness_relation_compatible' : forall s w, unit s => completeness_relation (Sub.insubd s) (EG.inzmod w) => completeness_relationG s w.
move => s w su . rewrite /completeness_relation /completeness_relationG /IsDL /=. 
rewrite /(^^).
rewrite EG.inzmodK.
rewrite - pow_mod. 
rewrite lll. apply g_unit. auto.
rewrite - bbb.
rewrite Sub.val_insubd.
have ->: (Sub.P ((ZModpField.exp g w))). rewrite /P. 
apply exp_lemma6. apply g_unit. simplify.
rewrite Sub.insubdK. rewrite /P. 
assumption. auto.
qed.



lemma llll (x y : zmod) : unit x => unit y => (Zps.( * ) (Sub.insubd x)  (Sub.insubd y) )= Sub.insubd (x * y).
progress. smt. qed.


lemma exp_lemma4 : forall (x : zmod) (n : int), unit x => (ZModpField.exp x q) = one =>  (ZModpField.exp x n) = Sub.val ((Sub.insubd x) ^^ (EG.inzmod n)). 
proof. progress. rewrite /(^^). rewrite lll. auto.
rewrite  EG.inzmodK.
have ->: (ZModpField.exp x (n %% q)) = (ZModpField.exp x n). smt.
rewrite Sub.insubdK.
smt.
auto.
qed.


lemma exp_lemma5 : forall (z : zmod) (n : int), unit z => 0 <= n => (ZModpField.exp z q) = one  => Sub.insubd z ^^ (EG.inzmod n) = (Zps.(^) (Sub.insubd z) n).
progress. rewrite /(^^). 
rewrite lll. auto. 
rewrite - bbb.
rewrite Sub.insubdK. rewrite /P. smt.
have ->: (EG.asint ((EG.inzmod n))%EG) = n %% q. smt.
rewrite lll. auto.  
rewrite Sub.insubdK. smt.
rewrite (Zp.exp_mod z n q _). auto. auto.
qed. 


lemma nosmt dokas : forall s w, s = ZModpField.exp g w => ZModpField.exp s q = one.
progress. 
have ->: (ZModpField.exp ((ZModpField.exp g w)) q) = (((ZModpField.exp g (w * q)))). 
 rewrite - ZModpField.exprM. auto.
have -> : w * q = q * w. smt().
have ->: (ZModpField.exp g (q * w)) = (ZModpField.exp ((ZModpField.exp g q)) w).
rewrite  ZModpField.exprM. auto.
rewrite  g_q_assumption. smt(@ZModpField).
qed.
  
lemma commitment_eq ss ww : 
 equiv [ SchnorrProver.commitment ~ HP.commitment : arg{2} = (ss,ww) ==> res{1}.`1 = (Sub.val res{2}) 
 /\ res{1}.`2 = EG.asint HP.r{2} 
 /\ HP.pa{2} = ss
 /\ HP.wa{2} = ww
].
proof. proc.
rnd EG.inzmod EG.asint. wp.  skip. progress.
smt(@EG). 
rewrite /EG.DZmodP.dunifin.
rewrite /EG.DZmodP.Support.enum.
rewrite duniform1E_uniq. smt(@List @EG).
rewrite duniform1E_uniq. smt(@List @EG).
simplify. smt(@EG @Distr @List).
rewrite EG.inzmodK.
 have f1 : rL \in range 0 q.
 smt(@Distr).
 have f2 : 0 <= rL < q. smt(@List).
 smt(@IntDiv).
rewrite exp_lemma4. apply g_unit. apply g_q_assumption. auto.
qed.


lemma nosmt in_chall_map b :
  (b \in map EG.inzmod challenges_list_zp) = ((EG.asint b) \in challenges_list_zp).
 have d1 : (b \in map EG.inzmod challenges_list_zp) => ((EG.asint b)%EG \in challenges_list_zp).
   move => q.
  have : (EG.inzmod ((EG.asint b))) \in (map EG.inzmod challenges_list_zp).  smt(@EG).
  move => qq. 
  have : exists x, x \in challenges_list_zp /\ (EG.inzmod (EG.asint b)) = EG.inzmod x.
   apply mapP. apply qq. elim.
   move => x. elim. move => xk. 
   rewrite EG.asintK. progress.
   rewrite EG.inzmodK. smt(@IntDiv list_elems). 
  simplify. 
 have d2 : ((EG.asint b)%EG \in challenges_list_zp) => (b \in map EG.inzmod challenges_list_zp).
   move => q.
   have ->: b = EG.inzmod (EG.asint b). smt(@EG).
   smt(@List).
   smt().
qed.


lemma challenge_eq  cc ss: 
 equiv [ SchnorrVerifier.challenge ~ HV.challenge : arg{2} = (ss,cc) ==> res{1} = EG.asint res{2} 
 /\ HV.c{2} = cc
 /\ HV.s{2} = ss
 /\ HV.ch{2} = res{2}
].
proof. proc. wp. 
rnd EG.inzmod EG.asint. wp.  skip. progress.
smt(@EG). 
rewrite duniform1E_uniq. 
apply map_inj_in_uniq. smt. smt().
rewrite duniform1E_uniq. smt().
rewrite in_chall_map. smt(@List).
smt(@Distr @List).
rewrite EG.inzmodK.
smt.
qed.
    

lemma response_eq : 
 equiv [ SchnorrProver.response ~ HP.response : 
  w{1} %% q = EG.asint HP.wa{2}
  /\ r{1} %% q = EG.asint HP.r{2}
  /\ c{1} %% q = EG.asint b{2}
  ==> res{1} = EG.asint res{2}
]. 
proof. proc. simplify.
wp. skip. progress.
have ->: (b{2})%EG \in  map EG.inzmod challenges_list_zp
 = c{1} %% q \in challenges_list_zp.
rewrite H1. apply in_chall_map.
case (c{1} %% q \in challenges_list_zp).
progress.
rewrite EG.addE.
rewrite EG.mulE.
rewrite - H0 - H1 - H. 
rewrite - modzDm.
congr. congr. congr.
smt(@IntDiv).
auto.
progress.
rewrite EG.addE.
rewrite EG.mulE.
rewrite /challenges_list_zp. simplify.
smt(@IntDiv @EG).
qed.


lemma verify_eq : 
 equiv [ SchnorrVerifier.verify ~ HV.verify : 
   s{1} <> zero
  /\ s{1} = Sub.val HV.s{2}
  /\ z{1} = Sub.val HV.c{2}
  /\ c{1} %% q = EG.asint HV.ch{2}
  /\ t{1} %% q = EG.asint r{2}
     ==> res{1} = res{2}
]. 
proc. simplify. skip.
move => &1 &2 [h1]. progress.
rewrite /verify_transcript. simplify.
rewrite /lift2.
case ((ZModpField.exp ((Sub.val HV.s{2})) q) = one).
move => G2. 
rewrite exp_lemma4. apply g_unit. apply g_q_assumption.
rewrite exp_lemma4. smt.   assumption. simplify.
have  <-: ((Sub.val ((Sub.insubd ((Sub.val HV.s{2}))) ^^ (EG.inzmod q))) = one)
 = ((Zps.(^) HV.s{2}  q) = (Sub.insubd one)).
rewrite - bbb.
rewrite exp_lemma5. smt.  smt(q_prime).
auto.
rewrite Sub.insubdK.  rewrite /P. smt.
have -> : (Sub.insubd ((Sub.val HV.s{2})))
 = HV.s{2}.
rewrite Sub.valKd. auto. auto.
rewrite Sub.valKd.
have -> : ((Sub.val (HV.s{2} ^^ (EG.inzmod q)%EG))%Sub = one). 
rewrite - G2.
smt.
simplify.
rewrite - bbb.
rewrite Sub.insubdK.
rewrite /P.
apply ZModpRing.unitrMr.
rewrite /(^^).
smt(@Sub).
smt(@Sub).
have ->:  (Sub.insubd g) ^^ (EG.inzmod t{1})
         = ((Sub.insubd g) ^^ r{2}).
   rewrite /(^^). rewrite - H0.
   rewrite EG.inzmodK. auto.
have ->: (HV.s{2} ^^ (EG.inzmod c{1}))
 = (HV.s{2} ^^ HV.ch{2}).
 rewrite /(^^). rewrite - H.
   rewrite EG.inzmodK. auto.
auto.
simplify.
move => eone.
have -> : (Zps.(^) HV.s{2} q) <> (Sub.insubd one).
 have->: HV.s{2} = Sub.insubd (Sub.val HV.s{2}).
 smt.
rewrite lll. smt.
smt. simplify.
auto.
qed.





module type MaliciousVerifierG = {
  proc challenge(s : statement, z : commitment) : challenge
  proc summitup(r : response) : summary
}.

module type ZKDistinguisherG  = {
  proc guess(statement : statement, witness : witness, summary : summary) : bool 
}.


module type RewMaliciousVerifierG = {
  proc challenge(s : statement, z : commitment) : challenge
  proc summitup(r : response) : summary
  proc getState() : sbits 
  proc setState(b : sbits) : unit 
}.


module type SimulatorG(V0 : RewMaliciousVerifierG)  = {
  proc simulate(statement : statement) : summary
}.


module ZKRealG(P : ZKProverG, V : MaliciousVerifierG, D : ZKDistinguisherG) = {
  proc run(statement : statement, witness : witness) : bool = {
    var commit, secret,  challenge, response, summary, guess;    
    (commit, secret) <@ P.commitment();
    challenge <@ V.challenge(statement, commit);
    response <@ P.response(witness, secret, challenge);
    summary <@ V.summitup(response);
    guess <@ D.guess(statement, witness, summary);
    return guess;
  }
}.


module ZKIdealG(S : SimulatorG, V0 : RewMaliciousVerifierG,
               D0 : ZKDistinguisherG) = {
  proc run(statement : statement, witness : witness) : bool = {
    var summary : summary;
    var guess : bool;
    summary <@ S(V0).simulate(statement);
    guess <@ D0.guess(statement, witness, summary);
    return guess;
  }
}.



section.

clone import SchnorrZeroKnowledge as SZK.


declare module V <: RewMaliciousVerifierG {-HP, -ZK.Hyb.Count, -ZK.Hyb.HybOrcl}.
declare module D <: ZKDistinguisherG{-HP, -ZK.Hyb.Count, -ZK.Hyb.HybOrcl}.


declare axiom Sim1_run_ll : forall (V0 <: RewMaliciousVerifier), 
 islossless V0.challenge 
  => islossless V0.summitup => islossless Sim1(V0).run.
declare axiom V_summitup_ll : islossless V.summitup. 
declare axiom V_challenge_ll : islossless V.challenge.
declare axiom D_guess_ll : islossless D.guess.
declare axiom P_response_ll : islossless HP.response.
declare axiom P_commitment_ll : islossless HP.commitment.
declare axiom simn_simulate_ll : forall (V0 <: RewMaliciousVerifier), islossless V0.challenge
  => islossless V0.summitup => islossless OSS.SimN(Sim1, V0).simulate.
declare axiom D_guess_prop : equiv[ D.guess ~ D.guess : ={glob V, arg} ==> ={res} ].

(* rewindability assumption *)
declare axiom rewindable_V_plus :
        (exists (f : glob V -> sbits),
         injective f /\
         (forall &m, Pr[ V.getState() @ &m : (glob V) = ((glob V){m})
                                          /\ res = f ((glob V){m} ) ] = 1%r) /\
         (forall &m b (x: glob V), b = f x =>
           Pr[V.setState(b) @ &m : glob V = x] = 1%r) /\
         islossless V.setState).




op zk_relationG (s : statement) (w : witness) = 
   0 <= w < q /\  (ZModpField.exp g w) = s.


lemma zk_relationG_implies_unit_s s w : 
  zk_relationG s w => unit s.
move => zk_rel.
elim zk_rel. elim.
move => _ _ eq.
rewrite - eq.
apply exp_lemma6. apply g_unit.
qed.


lemma zk_relations_compatible (s : statement) (w : witness) : 
  zk_relationG s w => zk_relation (Sub.insubd s) (EG.inzmod w).
progress. rewrite /zk_relation /IsDL.
elim H. elim. progress.
have ->: ZModpField.exp g w = ZModpField.exp g (w %% q).
rewrite - (exp_mod g w q). apply g_q_assumption. auto.
rewrite - lll.  apply g_unit.
rewrite /(^^).
rewrite EG.inzmodK.
auto.
qed.    


module V'(V : RewMaliciousVerifierG) : RewMaliciousVerifier = {
  proc challenge(s : dl_stat, d :  dl_com) : dl_chal = {
      var c;
      c <@ V.challenge(Sub.val s, Sub.val d);
      return (EG.inzmod c);
  }
  
  proc summitup(s : dl_stat, d : dl_resp) : summary  = {
      var c;
      c <@ V.summitup(EG.asint d);
      return c;    
  }
  proc getState = V.getState
  proc setState = V.setState
}.

module D'(D : ZKDistinguisherG) : ZKDistinguisher = {
  proc guess(statement : dl_stat, witness : dl_wit, summary : summary) : bool = {
    var r;
    r <@ D.guess(Sub.val statement, EG.asint witness, summary);
    return r;
  }
}.


module Sim1G(V : RewMaliciousVerifierG) = {
  module S = Sim1(V'(V))
  proc run(Ny : statement) : bool * summary = {
    var r;
    r <@ S.run(Sub.insubd Ny);        
    return r;
  }
}.

module SimNG(V0 : RewMaliciousVerifierG) = {
  module A = Sim1G(V0)
  
  proc simulate(statement : statement) : summary = {
    var c : int;
    var r : bool * summary;
    
    c <- 1;
    r <- (false, witness);
    while (c <= N /\ ! r.`1){
      r <@ A.run(statement);
      c <- c + 1;
    }    
    return r.`2;
  }
}.



local lemma zk_sim1_same ss:
 equiv [ Sim1G(V).run ~ Sim1(V'(V)).run :
   arg{1} = ss 
   /\ arg{2} = Sub.insubd ss
   /\  ={glob V} ==> ={res, glob V}].
proc. 
inline*. 
wp.
seq 15 14 : (={result,b,b',vstat,glob V}).
wp. call (_:true). simplify.
wp. simplify.
call (_:true). wp. 
rnd.  rnd.  wp. call (_:true). wp. 
skip. progress.
if. auto.
call (_:true). skip. progress.
skip.  auto.
qed.


local lemma zk_ideal_same &m stat wit : zk_relationG stat wit =>
  Pr[ZKIdeal(OSS.SimN(Sim1), V'(V), D'(D)).run(Sub.insubd stat, EG.inzmod wit)@&m : res]
  = Pr[ZKIdealG(SimNG, V, D).run(stat, wit)@&m : res].
move => wit_normal.
byequiv. proc.
inline D'(D).guess.
wp.
call D_guess_prop.
wp. 
inline OSS.SimN(Sim1, V'(V)).simulate.
inline SimNG(V).simulate.
wp. sp. simplify.
while (={c, glob V} /\ r0{1} = r{2} /\ statement1{1} = Sub.insubd statement0{2} /\ statement0{2} = stat).
wp.
symmetry.
call (zk_sim1_same stat).
skip. progress.
skip. progress. smt().
rewrite Sub.insubdK /P. 
apply (zk_relationG_implies_unit_s statement{2} witness{2});auto.
auto.
rewrite EG.inzmodK. smt(@IntDiv).
auto.
auto.
qed.

local lemma zk_real_same &m ss ww: zk_relationG ss ww =>
 Pr[ZKRealG(SchnorrProver, V,D).run(ss,ww)@&m : res]
 = Pr[ZKReal(HP, V'(V),D'(D)).run(Sub.insubd ss,EG.inzmod ww)@&m : res].
move => zk_rel_ss_ww.
byequiv. proc.
inline D'(D).guess. 
wp. call D_guess_prop.
simplify. wp.
inline V'(V).summitup. wp. 
call (_:true).
simplify.
wp.  
call response_eq. simplify.
inline V'(V).challenge. wp.  
call (_:true).
wp.  
call (commitment_eq (Sub.insubd ss) (EG.inzmod ww)).  
skip. progress. 
rewrite Sub.insubdK /P. 
apply (zk_relationG_implies_unit_s statement{1} witness{1}). auto. auto. 
smt().
smt(@EG).
smt(@EG).
smt(@EG).
rewrite EG.inzmodK. 
smt(@IntDiv).
auto.
auto.
qed.

lemma zp_schnorr_statistical_zk (stat : statement) (wit : witness) &m:
  zk_relationG stat wit =>
  let ideal_prob = Pr[ZKIdealG(SimNG, V, D).run(stat, wit)@&m : res] in
  let real_prob = Pr[ZKRealG(SchnorrProver,V,D).run(stat,wit)@&m : res] in
 `|ideal_prob - real_prob| <= 2%r * ((1%r - (1%r / (size challenges_list_zp)%r)) ^ N).
move => zk_rel_stat_wit. simplify.
rewrite zk_real_same. auto.
rewrite - zk_ideal_same. auto.
apply (schnorr_statistical_zk (V'(V)) (D'(D)) _ _ _ _ _ _ _ _ _ (Sub.insubd stat) 
 (EG.inzmod wit) &m).
apply Sim1_run_ll.
proc. call V_summitup_ll. auto.
proc. call V_challenge_ll. auto.
proc. call D_guess_ll. auto.
apply P_response_ll. 
apply P_commitment_ll. 
apply simn_simulate_ll.
proc. call D_guess_prop. skip. auto. simplify.
apply rewindable_V_plus.
apply zk_relations_compatible.
auto.
qed.


end section.








lemma completenessG (ss : statement) (ww : witness) &m: completeness_relationG ss ww =>
   Pr[ CompletenessG(SchnorrProver, SchnorrVerifier).main(ss,ww)@&m : res] = 1%r.
progress.
have statement_not_zero : unit ss. rewrite - H. apply exp_lemma6. apply g_unit.
rewrite /completeness_relation /IsDL in H.
rewrite - (LSP.dl_completeness (Sub.insubd ss) (EG.inzmod ww) &m). 
  apply completeness_relation_compatible. auto.
byequiv (_: _ ==> _). proc.
call (verify_eq). simplify.
call (response_eq). simplify.
ecall (challenge_eq commit{2} s{2}). 
ecall (commitment_eq s{2} w{2}). 
skip. progress.
smt(@EG). smt(@EG).
smt(@EG @IntDiv).
smt.
rewrite Sub.insubdK. assumption. auto.
smt(@EG).
auto.
auto.
qed.


(* Extractability  *)
import Rew.

(* Remove secret from commitment and response *)
module type ZKMaliciousProverG = {
  proc commitment() : commitment
  proc response(c : challenge) : response
}.


module type ZKRewindableMaliciousProverG = {
  proc commitment() : commitment
  proc response(c : challenge) : response
  proc getState() : sbits 
  proc setState(b : sbits) : unit 
}.

module SoundnessG(P : ZKMaliciousProverG, V : ZKVerifierG) = {
  proc run(s:statement) = {
    var z, c,t,v;
    z <@ P.commitment();
    c <@ V.challenge();
    t <@ P.response(c);
    v <@ V.verify(s,z,c,t);
    return v;
  }
}.

module type ExtractorG(P: ZKRewindableMaliciousProverG) = {
  proc extract(statement: statement): witness
}.

module SpecialSoundnessAdversaryG(P : ZKRewindableMaliciousProverG)  = {
  proc attack(statement:statement):(commitment * int * response) * (commitment * int * response) = {
    var i,c1,c2,r1,r2,pstate;
    i <@ P.commitment();
    c1 <$ duniform challenges_list_zp;
    pstate <@ P.getState();
    r1 <@ P.response(c1);
    c2 <$ duniform challenges_list_zp;
    P.setState(pstate);
    r2 <@ P.response(c2);
    return ((i,c1,r1), (i,c2,r2));
  }
}.


op special_soundness_extractG (t1 t2 : commitment * challenge * response): witness = 
 EG.asint (special_soundness_extract witness (Sub.insubd t1.`1, EG.inzmod t1.`2, EG.inzmod t1.`3) (Sub.insubd t2.`1, EG.inzmod t2.`2,EG.inzmod t2.`3)).

module (ExtractorG : ExtractorG)(P : ZKRewindableMaliciousProverG) = {  
  module SA = SpecialSoundnessAdversaryG(P)
  proc extract(p : statement) : witness = {
    var t1,t2;
    (t1,t2) <@ SA.attack(p);
    return special_soundness_extractG t1 t2;
 }
}.


section.

declare module P <: ZKRewindableMaliciousProverG{-HV}.
declare axiom P_response_ll : islossless P.response.
declare axiom P_commitment_ll : islossless P.commitment.

(* rewindability assumption *)
declare axiom rewindable_P_plus :
        (exists (f : glob P -> sbits),
         injective f /\
        (forall &m, Pr[ P.getState() @ &m : (glob P) = ((glob P){m})
                                          /\ res = f ((glob P){m} ) ] = 1%r) /\
        (forall &m b (x: glob P), b = f x =>
           Pr[P.setState(b) @ &m : glob P = x] = 1%r) /\ islossless P.setState).




local module P' = {
  proc commitment(s : dl_stat) : dl_com  = {
    var r;
    r <@ P.commitment();
    return (Sub.insubd r);
  }  
  proc response(challenge : dl_chal) : dl_resp  = {
    var r;
    r <@ P.response( EG.asint challenge);
    return (EG.inzmod r);
  }  
  proc getState = P.getState
  proc setState = P.setState
}.



lemma lles (a b : real) : 0%r <= a <= 1%r => 0%r <= b <= 1%r 
  => a  <= b  =>  a ^ 2 <= b ^ 2.
smt(@RealOrder).
qed.

lemma lles2 (a b x y : real) : 0%r <= a <= x => 0%r <= b <= y
  => a * b <= x * y.
smt(@Real @RealOrder).
qed.

lemma lles3 (a b : real) : 0%r < a => 0%r <= a * b => 0%r <= b.
progress.
smt(@Real @RealOrder).
qed.


lemma extractabilityG &m (sz : zmod): 
  Pr[ExtractorG(P).extract(sz) @ &m : completeness_relationG sz res ] >=
  (Pr[SoundnessG(P, SchnorrVerifier).run(sz) @ &m : res] ^ 2
       - 1%r / (size challenges_list_zp)%r
           * Pr[SoundnessG(P, SchnorrVerifier).run(sz) @ &m : res]).
proof. 
(* s = zero *)
case (sz = zero). move => s_is_zero.
  have ->: Pr[SoundnessG(P, SchnorrVerifier).run(sz) @ &m : res] = 0%r.
  pose ss := sz.
  byphoare (_: arg = sz ==> _). proc. hoare.
  inline*. wp.  call (_:true). wp. rnd. call(_:true). skip. progress. rewrite s_is_zero. 
  have ->: ZModpField.exp zero  q = zero. 
    rewrite (ZModpField.expr0z q). smt(q_prime).
  smt(@Zp). auto. auto. simplify.
  have ->: 0%r ^ 2 = 0%r. smt(@Real). 
  rewrite Pr[mu_ge0]. auto.
(* s <> zero *)
move => s_not_zero.
have soundness_less : Pr[SoundnessG(P, SchnorrVerifier).run(sz) @ &m : res]
 <= Pr[Soundness(P', HV).run(Sub.insubd sz) @ &m : res].
byequiv (_: _ ==> _).
proc.
seq 1 1 : ((z{1} <> zero => z{1} = Sub.val commit{2}) /\ (glob P){1} = (glob P){2} /\ s{1} = sz /\ Sub.val statement{2} = sz).
inline P'.commitment. wp.
call (_:true). wp.  skip. progress.
rewrite Sub.insubdK. smt. auto.
rewrite Sub.insubdK. smt. auto. 
case (z{1} = Zp.zero).
inline*. wp.
call {1} P_response_ll.
call {2} P_response_ll. auto.
rnd {1}.  rnd{2}.
wp. skip. progress. smt(@Distr). smt(@Distr).
have q : ZModpField.exp g result0  = zero.
rewrite H4. rewrite H. smt.
have : false. smt. auto.
smt. smt.
call verify_eq. simplify.
inline P'.response.
wp. call (_: true).
wp.  simplify.
ecall (challenge_eq commit{2} statement{2}). 
skip. progress.
auto.
smt(@EG).
smt(@EG).
smt(@EG).
auto.
auto.
have -> : Pr[ExtractorG(P).extract(sz) @ &m : completeness_relationG sz  res ] 
 = Pr[Extractor(P').extract(Sub.insubd sz) @ &m : soundness_relation (Sub.insubd sz) res].
byequiv. proc.
inline ExtractorG(P).SA.attack.
inline Extractor(P').SA.attack.
wp. simplify.
inline P'.response. wp.
call (_:true). wp.
call (_:true).
rnd EG.inzmod EG.asint. 
wp. call (_:true). wp.
call (_:true). rnd EG.inzmod EG.asint. wp.  
inline P'.commitment. wp.
call (_:true). wp.  skip. progress.
smt.
rewrite duniform1E_uniq. 
apply map_inj_in_uniq.  smt. smt().
rewrite duniform1E_uniq. auto.
  have ->: c1R \in map EG.inzmod challenges_list_zp. smt(@Distr). simplify.
  have ->: (EG.asint c1R)%EG \in challenges_list_zp.
  have : (EG.inzmod ((EG.asint c1R))) \in (map EG.inzmod challenges_list_zp). smt(@Distr).
  move => qq. 
  have : exists x, x \in challenges_list_zp /\ (EG.inzmod (EG.asint c1R)) = EG.inzmod x.
   apply mapP. apply qq. elim.
   move => x. elim. move => xk. 
   rewrite EG.asintK. progress.
   rewrite EG.inzmodK. smt(@IntDiv list_elems). 
  simplify. smt(@List).
smt(@Distr @List).
rewrite EG.inzmodK.  smt(list_elems @IntDiv @Distr).
smt(@Distr @List).
rewrite EG.inzmodK. 
smt(list_elems @IntDiv @Distr).
have -> : LSP.soundness_relation  =  LSP.completeness_relation. auto.
rewrite completeness_relation_compatible. simplify.
rewrite /completeness_relationG. rewrite - H11.  rewrite /special_soundness_extractG /special_soundness_extract. simplify.
rewrite EG.mulE.
smt.
have -: soundness_relation ((Sub.insubd p{1}))%Sub
      (special_soundness_extract ((Sub.insubd p{1}))%Sub
         ((Sub.insubd result_R)%Sub, (EG.inzmod c1L)%EG, (EG.inzmod result_R1)%EG)
         ((Sub.insubd result_R)%Sub, (EG.inzmod c2L)%EG, (EG.inzmod result_R2)%EG)). auto.
rewrite /soundness_relation /IsDL /special_soundness_extract. simplify.
rewrite /special_soundness_extractG. simplify. rewrite /special_soundness_extract.
simplify. 
rewrite /completeness_relationG.
rewrite EG.mulE.
rewrite - exp_mod. apply g_q_assumption.
rewrite /(^^).
rewrite EG.mulE.
rewrite lll. apply g_unit.
rewrite - exp_mod.  apply g_q_assumption.
move => q. apply aaa. 
smt(@ZModpField g_unit).
apply Zp.unitE. auto.
apply q.
auto.
auto.
have  :   Pr[Soundness(P', HV).run((Sub.insubd sz)%Sub) @ &m : res] ^ 2 -
  1%r / (size challenges_list_zp)%r *
  Pr[Soundness(P', HV).run((Sub.insubd sz)%Sub) @ &m : res] <=
  Pr[Extractor(P').extract((Sub.insubd sz)%Sub) @ &m :
     soundness_relation ((Sub.insubd sz))%Sub res]. 
apply (dl_statistical_PoK P' _ _ _ &m (Sub.insubd sz)).
proc. call P_response_ll. auto.
proc. call P_commitment_ll. auto.
apply rewindable_P_plus.
pose a:= Pr[Soundness(P', HV).run((Sub.insubd sz)) @ &m : res].
pose b:= Pr[Extractor(P').extract((Sub.insubd sz)%Sub) @ &m :
   soundness_relation ((Sub.insubd sz))%Sub res].
pose c := (size challenges_list_zp)%r.
pose q := Pr[SoundnessG(P, SchnorrVerifier).run(sz) @ &m : res].
progress.
case ((q ^ 2 - q / c) <= 0%r). smt.
move => pos. have impfact :  0%r < q * (q - 1%r / c). timeout 10. smt(@Real @RealOrder).
have : q <= a. auto. move => aq.
have ls1 : 0%r <= a <= 1%r. smt.
have ls2 : 0%r <= q <= 1%r. smt.
have : q ^ 2 - q / c  <=  a ^ 2 - a / c .
 have ->: q ^ 2 - q/c = q * (q  - 1%r/c). smt(@Real).
 have ->: a ^ 2 - a/c = a * (a  - 1%r/c). smt(@Real).
 have z: (q - 1%r / c) <= (a - 1%r / c). smt(@Real).
 apply lles2.  split. smt(@Real @RealOrder).
auto. 
split. 
apply (lles3 q). smt(@Real @RealOrder). smt(@Real @RealOrder).
auto.
smt(@Real @RealOrder).
qed.


end section.
