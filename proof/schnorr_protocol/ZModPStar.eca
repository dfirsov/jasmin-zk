require import AllCore.
require  ZModP Group.

op p : int.
axiom ge2_p: 2 <= p.

clone ZModP.ZModField as Zp with
  op p <= p
proof ge2_p.
realize ge2_p. apply ge2_p. qed.


require import IntDiv.
lemma exp_mod':
    forall (x : Zp.zmod) (n k : int),
      (Zp.ZModpField.exp x k) = Zp.one =>
      (Zp.ZModpField.exp x n) = (Zp.ZModpField.exp x (n %% k)).
proof. smt(@Zp). qed.

type zmod = Zp.zmod.

  
clone Subtype as Sub with
  type T <- zmod,
  op P = Zp.unit
proof*. 
realize inhabited. exists Zp.one. rewrite /P. rewrite /unit. exists Zp.one. smt(@Zp). qed.

type zmods = Sub.sT.


  
clone Group.ComGroup as Zps with
  type group <= zmods,
  op e <= Sub.insubd Zp.one,
  op ( * ) <= Sub.Lift.lift2 Zp.( * ),
  op inv <= Sub.Lift.lift1 Zp.inv
proof*.
realize mulcC. rewrite /lift2. smt(@Zp @Sub). qed.
realize mul1c. rewrite /lift2 /left_id. progress.  smt(@Zp @Sub). qed.
realize mulcA. rewrite /associative /lift2. progress. smt(@Zp @Sub). qed.
realize mulVc. rewrite /left_inverse /lift2 /lift1. progress. smt(@Zp @Sub). qed.


