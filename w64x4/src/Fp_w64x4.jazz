require "bn_generic.jazz"
require "ithbit.jazz"
require "swap.jazz"

param int nlimbs = 4;


inline fn cminusP ( stack u64[nlimbs] p x ) -> stack u64[nlimbs]{
  stack u64[nlimbs] t z;
  reg u64 _zero r1 r2;
  reg bool cf;

  z[0] = x[0];   z[1] = x[1];   z[2] = x[2];   z[3] = x[3];
  cf, t = bn_subc(z, p);

  r1 = t[0];
  r2 = x[0];
  r1 = r2 if cf;
  t[0] = r1;

  r1 = t[1];
  r2 = x[1];
  r1 = r2 if cf;
  t[1] = r1;

  r1 = t[2];
  r2 = x[2];
  r1 = r2 if cf;
  t[2] = r1;

  r1 = t[3];
  r2 = x[3];
  r1 = r2 if cf;
  t[3] = r1;

  return t;
}


/*  Modular addition  */
inline fn addm(stack u64[nlimbs] p a b) -> stack u64[nlimbs]
{
  stack u64[nlimbs] f g z;
  _, f = bn_addc (a,b);
  z[0] = f[0]; z[1] = f[1]; z[2] = f[2]; z[3] = f[3]; 
  f = cminusP (p,z);
  return f;
}


/*  Modular multiplication  */
inline fn mulm(stack u64[nlimbs] m x n) -> (stack u64[nlimbs]){
  reg u64 ctr bit d p par t1 t2 cbit lbit q;
  stack u64[nlimbs] x1 x2 x3 x4;
  ctr = nlimbs * 64 - 1;
  x1[0] = 0; x1[1] = 0; x1[2] = 0; x1[3] = 0;
  x2[0] = 0; x2[1] = 0; x2[2] = 0; x2[3] = 0;
  d = ith_bit(n,ctr);

   x3[0] = x[0]; x3[1] = x[1]; x3[2] = x[2]; x3[3] = x[3];
   x4 = addm(m,x,x);
   p = d;
   (x1,x3) = swapr(x1,x3,d);
   (x2,x4) = swapr(x2,x4,d);


  while(ctr > 0){
   lbit = ctr;
   ctr = ctr - 1;

   t1 =  ith_bit(n,lbit);
   t2 =  ith_bit(n,ctr);
   p = d; 
   q = d;
   d = d | t2;
   par = t1 ^ t2;
   (x1,x2) = swapr(x1,x2,par);
   x1 = addm(m,x1,x2);
   x2 = addm(m,x2,x2);
   q |= t2;
   cbit = q ^ p;
   (x1,x3) = swapr(x1,x3,cbit);
   (x2,x4) = swapr(x2,x4,cbit); 

  } 
   par = ith_bit(n,0);
   (x1,x2) = swapr(x2,x1,par);
  
  return x1;
}



export fn __addm(reg u64 rp pp ap bp) { 
  reg u64 rp2;
  stack u64[nlimbs] a b p;

  a = bn_load(ap);
  b = bn_load(bp);
  p = bn_load(pp);
  // relax ABI contraints
  rp2 = rp;
  a = addm(p,a,b);
  bn_store(rp2, a);
}


export fn __mulm(reg u64 rp pp ap bp) { 
  reg u64 rp2;
  stack u64[nlimbs] a b p;

  a = bn_load(ap);
  b = bn_load(bp);
  p = bn_load(pp);
  // relax ABI contraints
  rp2 = rp;
  a = mulm(p,a,b);
  bn_store(rp2, a);
}



inline fn toEC(){
  stack u64[nlimbs] a b r p;
  reg u64 x;
  reg bool _cf;
  
  /* normalized versions */
  r = addm(p,a, b);
  r = mulm(p,a, b);
  x = ith_bit(a, x);
  a = swapr(a, a, x);
}
