require "swap.jazz"
require "ithbit.jazz"
require "arith.jazz"


/*
  proc expm (x:int, n:bits) : int = {
    
    var x1, x2, x3, x4 : int;
    var ctr:int;
    var bit, d, p, par :bool;    
    d <- ith_bit n (size n - 1);
    (x1,x2,x3, x4) <- (1,1,x,x * x);

    ctr <- size n - 1;
    p <- d;
    (x1,x3) <- d ? (x3,x1) : (x1,x3);
    (x2,x4) <- d ? (x4,x2) : (x2,x4);

    while (0 < ctr) {
      ctr <- (ctr - 1);
      p <- d;
      d <- d || ith_bit n ctr;
      par <- ith_bit n (ctr + 1) ^ ith_bit n ctr;
      (x1,x2) <- if par then (x2,x1) else (x1, x2);
      x1 <- x1 * x2;
      x2 <- x2 * x2;
      (x1,x3) <- d ^ p ? (x3,x1) : (x1,x3);
      (x2,x4) <- d ^ p ? (x4,x2) : (x2,x4);
    }
    (x1,x2) <- if ! ith_bit n 0 then (x2,x1) else (x1, x2);    
    return x1;
  }  
*/




inline fn expm(reg u64 m x n) -> (reg u64, reg u64)
{
  reg u64 ctr x1 x2 x3 x4 bit d p par t1 t2 cbit lbit q;
  ctr = 4;

  d = __ith_bit64(n, 4);
  x1 = 1;
  x2 = 1;
  x3 = x;
  x4 = mulm(m,x,x);
  p = d;
  (x1,x3) = swap(x1,x3,d);
  (x2,x4) = swap(x2,x4,d);

while(ctr > 0){
   p = d; 

   t1 =  __ith_bit64(n,ctr);
    ctr = ctr -  1;

    t2 =  __ith_bit64(n,ctr);
    q = d;
    d = d | t2;
    par = t1 ^ t2;
    (x1,x2) = swap(x1,x2,par);
    x1 = mulm(m,x1,x2);
    x2 = mulm(m,x2,x2);
    q |= t2;
    par = q ^ p;
    (x1,x3) = swap(x1,x3,par);
    (x2,x4) = swap(x2,x4,par); 

} 

   par = __ith_bit64(n,0);
   (x1,x2) = swap(x2,x1,par); 
  return (x1,x2);



}



fn main() -> (reg u64, reg u64)  {
  reg u64 p x1 x2 r1 r2; 
  x1 = 5;
  x2 = 25;
  p = 13;
  r1, r2 = expm(p,x1,x2);
  return r1, r2;
}


exec main()