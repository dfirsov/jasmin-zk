require "ithbit.jazz"
require "swap.jazz"

param int bsize = 63;


/* @requires: is_prime(p)
   @requires: 0 <= a,b < p
   @ensures: res = (a+b)%p */
inline fn addm( reg u64 p a b ) -> reg u64 {
  reg bool _cf;
  reg u64 k1, k2, x;
  k1 = 0;
  k2 = 0;
  _cf, x = a + b;
  k1 = p if _cf;
  _cf, x = x - p;
  k2 = p if _cf;
  x += k2;
  x -= k1;
  return x;
}

/* @requires: is_prime(p)
   @requires: 0 <= a,b < p
   @ensures: res = (a-b)%p */
inline fn subm( reg u64 p a b ) -> reg u64 {
  reg bool _cf;
  reg u64 k, x;
  k = 0;
  _cf, x = a - b;
  k = p if _cf;
  x += k;
  return x;
}

/* @requires: is_prime(p)
   @requires: 0 <= a,b < p
   @ensures: res = (a*b)%p */
inline fn mulm( reg u64 p a b ) -> reg u64 {
  reg u64 ax, bx, mh, ml, q, r, x;
  ax = a;
  bx = b;
  _, _, _, _, _, mh, ml = #MUL( ax, bx );
  _, _, _, _, _, q, r = #DIV( mh, ml, p );
  x = r;
  return x;
}


/* montgomery ladder simple (leaky according to EasyCrypt extraction) */
inline fn expm_naive(reg u64  p x n) -> reg u64
{
  reg u64 ctr x1 x2 bit;

  ctr = 4;  
  x1 = x;
  x2 = mulm(p,x1,x1);

while{
    ctr -= 1;
    bit = __ith_bit64(n,ctr);
    if(bit == 0){
      x2 = mulm(p,x1,x2);
      x1 = mulm(p,x1,x1);
    }else{
      x1 = mulm(p,x1,x2);
      x2 = mulm(p,x2,x2);
    }

  } (ctr  > 0)

  return x1;
}

/* @requires: is_prime(p)
   @requires: 0 <= a,b < p
   @ensures: res = (a^b)%p */
inline fn expm(reg u64 m x n) -> (reg u64)
{
  reg u64 ctr x1 x2 x3 x4 ctr lbit t1 t2;
  ctr = bsize;

  reg bool d par cbit bit p q t1 t2;

  d = __ith_bitb64(n,ctr);
  x1 = 1;
  x2 = 1;
  x3 = x;
  x4 = mulm(m,x,x);

  p = d;
  (x1,x3) = swapb(x1,x3,d);
  (x2,x4) = swapb(x2,x4,d);

while(ctr > 0){
   lbit = ctr;
   ctr = ctr - 1;

   t1 =  __ith_bitb64(n,lbit);
   t2 =  __ith_bitb64(n,ctr);


   par =  (t1 && (t2 == false)) || ( (t1 == false) && t2) ;
   (x1,x2) = swapb(x1,x2,par);
   x1 = mulm(m,x1,x2);
   x2 = mulm(m,x2,x2);
   cbit = ((d || t2) && (d == false)) || ( ((d || t2) == false) && d) ; 
   (x1,x3) = swapb(x1,x3,cbit);
   (x2,x4) = swapb(x2,x4,cbit); 

   d = d || t2;
   
} 

  par = __ith_bitb64(n,0);
  (x1,x2) = swapb(x2,x1,par); 

  return x1;
}


export fn __addm( reg u64 p a b ) -> reg u64 { 
  reg u64 _p, _a, _b, _r, r;
  _a = a;
  _b = b;
  _p = p;
  _r = addm(_p, _a, _b);
  r = _r;
  return r;
}

export fn __subm( reg u64 p a b ) -> reg u64 { 
  reg u64 _p, _a, _b, _r, r;
  _a = a;
  _b = b;
  _p = p;
  _r = subm(_p, _a, _b);
  r = _r;
  return r;
}

export fn __mulm( reg u64 p a b ) -> reg u64 { 
  reg u64 _p, _a, _b, _r, r;
  _a = a;
  _b = b;
  _p = p;
  _r = mulm(_p, _a, _b);
  r = _r;
  return r;
}




fn main() -> (reg u64)  {
  reg u64 p x1 x2 r1 r2; 
  x1 = 4;
  x2 = 5;
  p = 13;
  r1 = expm(p,x1,x2);
  return r1;
}



exec main()
